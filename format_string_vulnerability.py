#!/usr/bin/env python

from idaapi import *
from idc import *
from idautils import *

danger_funcs = ["alloca", "_alloca", "scanf", "wscanf", "sscanf", "swscanf", "vscanf", "vsscanf", "strlen", "wcslen", "strtok", "strtok_r", "wcstok", "strcat", "strncat", "wcscat", "wcsncat", "strcpy", "strncpy", "wcscpy", "wcsncpy", "memcpy", "wmemcpy", "stpcpy",
                "stpncpy", "wcpcpy", "wcpncpy", "memmove", "wmemmove", "memcmp", "wmemcmp", "memset", "wmemset", "gets", "sprintf", "vsprintf", "swprintf", "vswprintf", "snprintf", "vsnprintf", "realpath", "getwd", "wctomb", "wcrtomb", "wcstombs", "wcsrtombs", "wcsnrtombs"]
_danger_funcs = ["_"+x for x in danger_funcs]
danger_funcs += _danger_funcs

# 获取函数的可引用地址


def GetFuncAddr(func):
    addr = get_name_ea_simple(func)
    if addr == BADADDR:
        return addr
    segm = get_segm_name(addr)
    if segm == "extern":
        # extern地址交叉引用地址属于.got.plt或.got
        addr = get_first_dref_to(addr)
        if addr != BADADDR:
            segm = get_segm_name(addr)
            if segm not in [".got.plt", ".got"]:
                return BADADDR
            # got表的交叉引用地址在plt段
            addr = get_first_dref_to(addr)
            if addr != BADADDR:
                segm = get_segm_name(addr)
                if segm != ".plt":
                    return BADADDR
    elif segm != ".text":
        addr = BADADDR
    return addr

# 标记所以调用危险函数的指令地址


def FlagCall(func):
    addr = GetFuncAddr(func)
    if addr != BADADDR:
        print("[*] %s Referenceable address %s" % (func, hex(addr)))
        xrefs = CodeRefsTo(addr, 0)
        for ref in xrefs:
            print("[+]", hex(ref), GetDisasm(ref))
            set_color(ref, CIC_ITEM, 0x0000ff)


def get_arg(addr, arg_num, bits):
    # 64位传参寄存器
    if("ELF" in get_file_type_name()):
        arg_list_x64 = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
        arg_list_x64_2 = ["edi", "esi", "edx", "ecx", "r8", "r9"]
    elif("PE" in get_file_type_name()):
        arg_list_x64 = ["rcx", "rdx", "r8", "r9"]
        arg_list_x64_2 = ["ecx", "edx", "r8", "r9"]

    func_start = get_func_attr(addr, FUNCATTR_START)
    arg_count = -1
    while True:
        # 向前遍历指令
        addr = prev_head(addr)
        # 获取指令助记符
        mnem = print_insn_mnem(addr)
        if mnem in ("ret", "retn", "jmp", "b") or addr < func_start:
            return -1
        # 获取函数指定参数
        if bits == 32:
            if mnem == "push":
                arg_count += 1
                if arg_count == arg_num:
                    return addr
            elif mnem in ["mov", "lea"]:
                if "[esp]" in print_operand(addr, 0):
                    arg_count += 1
                    if arg_count == arg_num:
                        return addr
        elif bits == 64:
            if mnem in ["mov", "lea"]:
                if print_operand(addr, 0) in [arg_list_x64[arg_num], arg_list_x64_2[arg_num]]:
                    return addr


def check_fmt_function(bits):
    if bits not in [32, 64]:
        print("unknown bits")
        return
    danger_funcs = {
        "printf": 0,
        "sprintf": 1,
        "fprintf": 1
    }
    func_no_count = 0
    for func, arg_num in danger_funcs.items():
        # 获取可引用地址
        addr = GetFuncAddr(func)
        if addr == BADADDR:
            func_no_count += 1
            if func_no_count == len(danger_funcs):
                print(
                    "[*] This file does not call any konwn format string dangerous functions!")
            continue
        print("[*] %s Referenceable address %s" % (func, hex(addr)))
        # 获取调用 printf 函数的地址
        xrefs = CodeRefsTo(addr, 0)
        for ref in xrefs:
            out_break = 0
            addr = ref
            func_start = get_func_attr(addr, FUNCATTR_START)
            ref = addr
            addr = get_arg(addr, arg_num, bits)
            if addr == -1:
                continue
            # 获取操作数
            item = GetDisasm(addr)
            op_index = item.split(';')[0].count(",")
            op_type = get_operand_type(addr, op_index)
            operand = print_operand(addr, op_index)
            # 赋值给第一参数的操作数是通用寄存器，寻找此寄存器的赋值
            if op_type == o_reg:
                _addr = addr
                while True:
                    _addr = prev_head(_addr)
                    mnem = print_insn_mnem(_addr)
                    _operand = print_operand(_addr, 0)
                    if mnem in ("ret", "retn", "jmp", "b") or _addr < func_start:
                        out_break = 1
                        break
                    elif mnem in ["mov", "lea", "ldr"]:
                        if (operand == _operand or (operand[1:] == _operand[1:] and operand[0] in ['r', 'e'] and _operand[0] in ['r', 'e'])):
                            op_type = get_operand_type(_addr, 1)
                            op_index = GetDisasm(_addr).split(';')[
                                0].count(",")
                            operand = print_operand(_addr, 1)
                            addr = _addr
                            if op_type != o_reg:
                                break
            if out_break == 1:
                continue
            # 赋值给第一参数的操作数是立即数或内存引用
            if op_type in [o_imm, o_mem]:
                op_addr = get_operand_value(addr, op_index)
                segm = getseg(op_addr)
                if segm:
                    # 是否可写
                    if not (segm.perm & SEGPERM_WRITE):
                        continue
                else:
                    continue
            print("[!] maybe format string vulnerability : %s" % hex(ref))
            set_color(ref, CIC_ITEM, 0x0000ff)

# 动态获取cpu位数


def get_arch_dynamic():
    idainfo = get_inf_structure()
    if idainfo.is_64bit():
        return 64
    elif idainfo.is_32bit():
        return 32
    else:
        return 0


class format_string_vulnerability(plugin_t):
    flags = PLUGIN_UNL
    comment = ""
    help = "This plugin can check for format string dangerous functions."
    wanted_name = "Format String vuln"
    wanted_hotkey = ""

    def init(self):
        return PLUGIN_OK

    def run(self, arg):
        print("===================================================================")
        check_fmt_function(get_arch_dynamic())

    def term(self):
        pass


def PLUGIN_ENTRY():
    return format_string_vulnerability()
