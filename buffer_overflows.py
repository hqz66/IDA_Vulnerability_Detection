from idaapi import *
from idc import *
from idautils import *


# 动态获取cpu位数
def get_arch_dynamic():
    idainfo = get_inf_structure()
    if idainfo.is_64bit():
        return 64
    elif idainfo.is_32bit():
        return 32
    else:
        return 0

# 获取函数的可引用地址


def GetFuncAddr(func):
    addr = get_name_ea_simple(func)
    if addr == BADADDR:
        return addr
    segm = get_segm_name(addr)
    if segm == "extern":
        # extern地址交叉引用地址属于.got.plt或.got
        addr = get_first_dref_to(addr)
        if addr != BADADDR:
            segm = get_segm_name(addr)
            if segm not in [".got.plt", ".got"]:
                return BADADDR
            # got表的交叉引用地址在plt段
            addr = get_first_dref_to(addr)
            if addr != BADADDR:
                segm = get_segm_name(addr)
                if segm != ".plt":
                    return BADADDR
    elif segm != ".text":
        addr = BADADDR
    return addr

# 判断栈的大小是否足够大


def frame_size(func):
    # 可能出现栈溢出的变量大小，最小阈值
    minsize = 16
    # 遍历所有函数
    flags = get_func_attr(func, FUNCATTR_FLAGS)
    if not (flags & FUNC_FRAME):
        return -1
    prev_count = -1
    frame_counter = 0
    prev_var = None
    stack_frame = get_func_attr(func, FUNCATTR_FRAME)
    if stack_frame == -1:
        return -1
    # 获取栈的大小
    frame_size = get_struc_size(stack_frame)
    print("[*] function address : %s, frame_size: %d" %
          (hex(func), frame_size))
    if stack_frame < minsize:
        return -1
    # 遍历每个变量，将足够大的变量打印出来
    flag = 0
    while frame_counter < frame_size:
        stack_var = get_member_name(stack_frame, frame_counter)
        if stack_var is not None:
            if prev_count != -1:
                member_size = frame_counter - prev_count
                if member_size >= minsize:
                    print("[*] function name : %s -> stack variable: %s (%d bytes)" %
                          (get_func_name(func), prev_var, member_size))
                    flag = 1
            prev_count = frame_counter
            prev_var = stack_var
            frame_counter += get_member_size(stack_frame, frame_counter)
        else:
            frame_counter = frame_counter + 1
    if flag == 1:
        return 1
    return -1


def get_arg(addr, arg_num, bits):
    # 64位传参寄存器
    if("ELF" in get_file_type_name()):
        arg_list_x64 = ["rdi", "rsi", "rdx", "rcx", "r8", "r9"]
        arg_list_x64_2 = ["edi", "esi", "edx", "ecx", "r8", "r9"]
    elif("PE" in get_file_type_name()):
        arg_list_x64 = ["rcx", "rdx", "r8", "r9"]
        arg_list_x64_2 = ["ecx", "edx", "r8", "r9"]

    func_start = get_func_attr(addr, FUNCATTR_START)
    arg_count = -1
    while True:
        # 向前遍历指令
        addr = prev_head(addr)
        # 获取指令助记符
        mnem = print_insn_mnem(addr)
        if mnem in ("ret", "retn", "jmp", "b") or addr < func_start:
            return -1
        # 获取函数指定参数
        if bits == 32:
            if mnem == "push":
                arg_count += 1
                if arg_count == arg_num:
                    return print_operand(addr, 0)
            elif mnem in ["mov", "lea"]:
                if "[esp]" in print_operand(addr, 0):
                    arg_count += 1
                    if arg_count == arg_num:
                        return print_operand(addr, 1)
        elif bits == 64:
            if mnem in ["mov", "lea"]:
                if print_operand(addr, 0) in [arg_list_x64[arg_num], arg_list_x64_2[arg_num]]:
                    return print_operand(addr, 1)


# 判断参数是否是栈变量
def is_stack_buffer(addr, idx):
    inst = DecodeInstruction(addr)
    ret = get_stkvar(inst, inst[idx], inst[idx].addr)
    return ret

# 检测内联strcpy和strcat


def inline_strcpy(bits):
    ea = 0
    while ea != BADADDR:
        addr = find_text(ea+2, SEARCH_DOWN | SEARCH_NEXT, 0, 0, "rep movsd")
        ea = addr
        # rep movsd紧接着movesb
        if "movesb" in GetDisasm(addr+7):
            opnd = "edi"
            if bits == 64:
                opnd = "rdi"
            func_start = get_func_attr(_addr, FUNCATTR_START)
            if frame_size(func_start) < 0:
                continue
            while True:
                _addr = prev_head(_addr)
                mnem = print_insn_mnem(_addr)
                operand = print_operand(_addr, 0)
                if mnem in ("ret", "retn", "jmp", "b") or _addr < func_start:
                    break
                elif mnem == "lea" and operand == opnd:
                    if is_stack_buffer(_addr, 1):
                        print("[!] stack buffer strcpy found at ", hex(addr))
                        break
                    else:
                        break
                elif mnem == "mov" and operand == opnd:
                    op_type = get_operand_type(_addr, 1)
                    if op_type == o_reg:
                        opnd = print_operand(_addr, 1)
                        addr = _addr
                    else:
                        break


# 检测缓冲区溢出主函数
def check_stack(bits):
    if bits not in [32, 64]:
        print("unknown bits")
        return
    # 缓冲区溢出危险函数
    danger_funcs = {
        "strcpy": 0,
        "strcat": 0
    }
    func_no_count = 0
    for func, arg_num in danger_funcs.items():
        addr = GetFuncAddr(func)
        if addr == BADADDR:
            func_no_count += 1
            if func_no_count == len(danger_funcs):
                print(
                    "[*] This file does not call any known buffer overflow hazard functions!")
            continue
        print("[*] %s Referenceable address %s" % (func, hex(addr)))
        xrefs = CodeRefsTo(addr, 0)
        for ref in xrefs:
            print("[+]", hex(ref), GetDisasm(ref))
            func_start = get_func_attr(ref, FUNCATTR_START)
            if frame_size(func_start) < 0:
                continue
            opnd = get_arg(ref, arg_num, bits)
            if opnd == -1:
                continue
            addr = ref
            while True:
                addr = prev_head(addr)
                mnem = print_insn_mnem(addr)
                operand = print_operand(addr, 0)
                if mnem in ("ret", "retn", "jmp", "b") or addr < func_start:
                    break
                elif mnem == "lea":
                    if (operand == opnd or (operand[1:] == opnd[1:] and operand[0] in ['r', 'e'] and opnd[0] in ['r', 'e'])):
                        if is_stack_buffer(addr, 1):
                            print("[!] stack buffer strcpy found at ", hex(addr))
                            break
                elif mnem == "mov":
                    if (operand == opnd or (operand[1:] == opnd[1:] and operand[0] in ['r', 'e'] and opnd[0] in ['r', 'e'])):
                        op_type = get_operand_type(addr, 1)
                        if op_type == o_reg:
                            opnd = print_operand(addr, 1)
                        else:
                            break


class buffer_overflows(plugin_t):
    flags = PLUGIN_UNL
    comment = ""
    help = "This plugin can check for buffer overflow dangerous functions."
    wanted_name = "Buffer Overflow Functions"
    wanted_hotkey = ""

    def init(self):
        return PLUGIN_OK

    def run(self, arg):
        print("===================================================================")
        check_stack(get_arch_dynamic())

    def term(self):
        pass


def PLUGIN_ENTRY():
    return buffer_overflows()
